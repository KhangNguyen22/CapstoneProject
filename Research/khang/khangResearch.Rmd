---
title: "Khang Research 1"
output: html_notebook
---

```{r, include=FALSE}
library(tidyverse)
library(tuneR)
library(devtools)
library(ggplot2)
library(tsfeatures)
library(class)
library(cvTools)
library(randomForest)
library(GEOquery) 
library(R.utils)
library(reshape2)
library(limma)
library(dplyr)
library(e1071)
library(DT)
library(viridis)
library(plotly)
library(scales)
library(CPOP)
library(matrixStats)
library(visNetwork)


library(furrr)
library(tictoc)
```

## Mukund CPOP analysis

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
#CPOP data

# AMY, CHARLOTTE, LIAM, if anyone does this on their local computer, uncomment the following
# original import from server
# GSE46474 = getGEO("GSE46474")[[1]]
# GSE36059 = getGEO("GSE36059")[[1]]
# GSE48581 = getGEO("GSE48581")[[1]]
# The below is what the user uploads
# GSE129166 = getGEO("GSE129166")[[1]]

# write to file, TODO: For each object, please RDS to speed it up
# saveRDS(GSE46474, file = "GSE46474.rds")
# saveRDS(GSE36059, file = "GSE36059.rds")
# saveRDS(GSE129166, file = "GSE129166.rds")


GSE46474 <- readRDS("GSE46474.rds")
GSE36059 <-  readRDS("GSE36059.rds")
GSE48581 <-  readRDS("GSE48581.rds")
# GSE129166 <- readRDS("GSE129166.rds")
```

```{r include=FALSE}


# TODO: make this into an rds object that you can reference later
bridgegse <- GSE46474 # the dataset we want to get the gene symbols from

affymetrixGenes = unlist(lapply(strsplit(fData(bridgegse)$`Gene Symbol`, " /// ", 1), `[`, 1))

idx = which(!duplicated(affymetrixGenes) & !is.na(affymetrixGenes))

bridge =  data.frame(id = fData(bridgegse)$ID[idx], geneName= affymetrixGenes[idx])
# saveRDS(bridge, file = "../../shinyapp/data/bridge.rds")


gene_names = function(gse) {
  fData(gse)$`Gene Symbol` = unlist(lapply(strsplit(fData(gse)$`Gene Symbol`, " /// ", 1), `[`, 1))

  idx = which(!duplicated(fData(gse)$`Gene Symbol`) & !is.na(fData(gse)$`Gene Symbol`))
  gse = gse[idx,] # get only rows that have a gene symbol that is unique, which enables the rownames
  rownames(gse) = fData(gse)$`Gene Symbol`
  
  return(gse)
}

# changes probe Ids into gene names
transformProbeIds = function(df){
  temp <- rownames(df)

  rowIndexesToKeep <- c()
  newRowNames <- c()
  for(i in 1:length(temp)){
    curIndex <- which(bridge$id == temp[i])
    if( length(curIndex) == 1 ){
      rowIndexesToKeep <-  c(rowIndexesToKeep, i)
      newRowNames <- c(newRowNames, bridge[curIndex, "geneName"])
    }
  }
  df <- df[rowIndexesToKeep,]
  rownames(df) <- newRowNames
  
  return(df)
}
```


# Create function for user input and compare with 3 datasets

```{r, include=FALSE}
calc_mode <- function(x){
  # List the distinct / unique values
  distinct_values <- unique(x)
  # Count the occurrence of each distinct value
  distinct_tabulate <- tabulate(match(x, distinct_values))
  # Return the value with the highest occurrence
  distinct_values[which.max(distinct_tabulate)]
}

set.seed(3888)
generateCPOPmodel <- function(user,userOutcomes, public){
  return(cpop_model(user,
        public[[1]], # public[1] is the expression matrix only
        userOutcomes,
        public[[2]], #public[2] is the public Outcomes
        w = NULL,
        n_features = 30,
        n_iter = 30,
        alpha = 0,
        family = "binomial",
        s = "lambda.min",
        cpop2_break = TRUE,
        cpop2_type = "sign",
        cpop2_mag = 1,
        cpop1_method = "normal",
        intercept = FALSE))
}
```


```{r}
# user inputs their file upload
userFile <- data.frame(read_csv('../Liam/Data/dirtyuser.csv', name_repair = "minimal"))
rownames(userFile) <-  tolower(userFile[[1]])
userFile <-  userFile[,-1]
diagnosisIndex <- which(rownames(userFile) == 'diagnosis')

# separate for individual cleaning
userExpression <- userFile[-diagnosisIndex,]
userBinaryOutcomes <-  as.factor(unname(unlist(userFile[diagnosisIndex, ])))

# transform probe ids to gene names, will make userExpression smaller
userExpression <- transformProbeIds(userExpression)

# I calculate the variance so I can get the userExpression to 2000 rows
myVar = rowVars(as.matrix(userExpression), na.rm=TRUE)
myVar = as.data.frame(myVar)

userExpression = cbind(userExpression, variance = myVar)
userExpression = slice_max(userExpression, order_by = myVar, n = 2000)
userExpression = subset(userExpression, select = -c(myVar))

# get the row names (probe ids) before transpose
row_names_UE= rownames(userExpression)

userExpression <- as.data.frame(t(userExpression))

# actually clean the userExpression matrix
userExpression <- userExpression %>% mutate_if(is.numeric, ~replace_na(.,mean(., na.rm = TRUE)))

# actually clean the NAs in userBinary Outcomes
f <- calc_mode(userBinaryOutcomes)
majorityClass <- as.numeric(levels(f))[f]
userBinaryOutcomes[is.na(userBinaryOutcomes)] <- majorityClass

# row.names(userExpression) <- newR
# feature1 <-generateCPOPmodel(userExpression,userBinaryOutcomes,z1,y1)



```

```{r,include=FALSE}

GSE46474 = gene_names(GSE46474)
GSE36059 = gene_names(GSE36059)
GSE48581 = gene_names(GSE48581)
# TODO: save RDS object  of the exp_GSE expression dataframes
## keeping only the 2000 most variable genes in my data frame 
exp_GSE36059 = (exprs(GSE36059))

Variance = rowVars(as.matrix(exp_GSE36059)) #
Variance = as.data.frame(Variance)

exp_GSE36059 = as.data.frame(exp_GSE36059)

exp_GSE36059 = cbind(exp_GSE36059, variance = Variance)
exp_GSE36059 = slice_max(exp_GSE36059, order_by = Variance, n = 2000) # For each column, get the 2000 most variable genes, so you get 2000 rows
exp_GSE36059 = subset(exp_GSE36059, select = -c(Variance))

row_names_exp_GSE36059 = rownames(exp_GSE36059) # used for finding common probe ids


## keeping only the 2000 most variable genes in my data frame 
exp_GSE46474 = (exprs(GSE46474))

Variance = rowVars(as.matrix(exp_GSE46474))
Variance = as.data.frame(Variance)
exp_GSE46474 = as.data.frame(exp_GSE46474)


exp_GSE46474 = cbind(exp_GSE46474, variance = Variance)
exp_GSE46474 = slice_max(exp_GSE46474, order_by = Variance, n = 2000)
exp_GSE46474 = subset(exp_GSE46474, select = -c(Variance))
row_names_exp_GSE46474 = rownames(exp_GSE46474)



## keeping only the 2000 most variable genes in my data frame 
exp_GSE48581 = (exprs(GSE48581))
Variance = rowVars(as.matrix(exp_GSE48581))
Variance = as.data.frame(Variance)
exp_GSE48581 = as.data.frame(exp_GSE48581)
exp_GSE48581 = cbind(exp_GSE48581, variance = Variance)
exp_GSE48581 = slice_max(exp_GSE48581, order_by = Variance, n = 2000)
exp_GSE48581 = subset(exp_GSE48581, select = -c(Variance))
row_names_exp_GSE48581 = rownames(exp_GSE48581)
```

```{r, include=FALSE}
## now find the most common probe ids names between 3 datasets
intersection = intersect(row_names_exp_GSE36059, row_names_exp_GSE46474)
intersection = intersect(intersection, row_names_exp_GSE48581)
intersection = intersect(intersection, row_names_UE)
```

```{r, include= FALSE}
# create dataframes that only contains rows common in all dataframes
exp_GSE36059 = as.data.frame(t(as.matrix(exp_GSE36059)))
exp_GSE36059 = subset(exp_GSE36059, select = c(intersection)) # select rows that contain the probe ids in intersection

exp_GSE46474 = as.data.frame(t(as.matrix(exp_GSE46474)))
exp_GSE46474 = subset(exp_GSE46474, select = c(intersection)) # select rows that contain the probe ids in intersection

exp_GSE48581 = as.data.frame(t(as.matrix(exp_GSE48581)))
exp_GSE48581 = subset(exp_GSE48581, select = c(intersection)) # select rows that contain the probe ids in intersection

# no need to transpose as you already have done so above for user expression
userExpression <-  subset(userExpression, select= c(intersection))
```


## getting the results vectors

```{r, include= FALSE}

# CPOP stuff continued
p_GSE46474 = pData(GSE46474) 
p_GSE48581 = pData(GSE48581) 
p_GSE36059 = pData(GSE36059) 

# creating the outcome columns to put inside CPOP
p_GSE36059$diagnosis = ifelse(p_GSE36059$characteristics_ch1 == "diagnosis: non-rejecting", 0, 1)
p_GSE48581$diagnosis = ifelse(p_GSE48581$characteristics_ch1.1 == "diagnosis (tcmr, abmr, mixed, non-rejecting, nephrectomy): non-rejecting", 0, 1)
p_GSE46474$diagnosis = ifelse(p_GSE46474$characteristics_ch1.5 == "procedure status: post-transplant non-rejection (NR)", 0, 1)


z1 = exp_GSE36059 %>% as.matrix() # used for box plots and CPOP
z2 = exp_GSE48581 %>% as.matrix()
z3 = exp_GSE46474 %>% as.matrix()
userExpression <- userExpression %>% as.matrix()

y1 = as.factor(p_GSE36059$diagnosis)
y2 = as.factor(p_GSE48581$diagnosis)
y3 = as.factor(p_GSE46474$diagnosis)



### GSE36059
### GSE48581
# these have reject + stable but categorized in more detail -> either have more groups that we are predicting, or we could do purely binary 
```
## CPOP RUN KHANG
<!-- TODO: Implement this pairwise difference in shiny app -->

```{r}
future::plan(multisession)
tic()
cpopOutputs <- future_map(list(list(z1,y1),list(z2,y2), list(z3,y3)), generateCPOPmodel, user= userExpression, userOutcomes=userBinaryOutcomes)
toc()
```


```{r}
# feature1 <- generateCPOPmodel(userExpression,userBinaryOutcomes,list(z1,y1))
# feature2 <- generateCPOPmodel(userExpression,userBinaryOutcomes,list(z2,y2))
# feature3 <- generateCPOPmodel(userExpression,userBinaryOutcomes,list(z3,y3))

f1 <-  cpopOutputs[[1]]$coef_tbl$coef_name[-1] 
f2 <- cpopOutputs[[2]]$coef_tbl$coef_name[-1]
f3 <- cpopOutputs[[3]]$coef_tbl$coef_name[-1]

rI <- intersect(f1,f2)
stableFeatures <- intersect(rI,f3)
# generateCPOPmodel(z1,y1,z2,y2)

# after finding the stable features, get rows relevant in each dataframe and create your own data frame.
# we will do a column bind
tb1 <-  cpopOutputs[[1]]$coef_tbl[cpopOutputs[[1]]$coef_tbl$coef_name %in% stableFeatures,]
tb2 <-  cpopOutputs[[2]]$coef_tbl[cpopOutputs[[2]]$coef_tbl$coef_name %in% stableFeatures,]
tb3 <-  cpopOutputs[[3]]$coef_tbl[cpopOutputs[[3]]$coef_tbl$coef_name %in% stableFeatures,]


results <- tb1 %>% inner_join(tb2, by ="coef_name" ) %>% inner_join(tb3, by ="coef_name" )
results$average <- rowMeans(results[,-1])
# resultTable$average
# -0.12109045	-0.07927375	AGL--ANKRD22
# -0.069795029	-0.025225051 AGL--ANKRD22
# -0.07525255	-0.023783883
# length(stableFeatures)

coef = results$coef_name

# saveRDS(stableFeatures, file = "../../shinyapp/data/stableFeatures.rds")
```


## VisNetwork!!
```{r}
results = results %>% mutate(color = case_when( average > 0 ~ "turquoise", average < 0 ~ "orange" ))
names = data.frame(feature1 = rep("",length(coef)),
                   feature2 = rep("",length(coef)),
                   coef_size = abs(results$average))
#names
names$feature1 = sub("--.*", "", coef) #getting the first node from the coef-name vector of the results df
names$feature2 = sub(".*--", "", coef) #getting the second node from the coef-name vector of the results df
names$color = results$color
# network = plot_lratio_network(coef, type = "visNetwork")
#network
names_uniq = unique(c(names$feature1, names$feature2))
# names_uniq
numbers = names
#numbers
for (a in 1:nrow(numbers)) {
  for (i in 1:length(names_uniq)) {
    if (numbers$feature2[a] == names_uniq[i]) {
      numbers$feature2[a] = i
    }
  }
}
for (a in 1:nrow(numbers)) {
  for (i in 1:length(names_uniq)) {
    if (numbers$feature1[a] == names_uniq[i]) {
      numbers$feature1[a] = i
    }
  }
}
#numbers
clr = c()
for (a in 1:length(names_uniq)) {
  for (i in 1:nrow(names)) {
    if (names_uniq[a] == names[i,1] | names_uniq[a] == names[i,2]) {
      clr[a] = names$color[i]
    }
  }
}
#clr

cleanNames <- sub("--.*","",names_uniq)

edges = data.frame(from = numbers$feature1, to = numbers$feature2, value = names$coef_size)
nodes = data.frame(id = c(1:length(names_uniq)), 
                   label = names_uniq, 
                   # color = clr,
                   title = paste0('<a href = "https://www.genecards.org/cgi-bin/carddisp.pl?gene=',cleanNames,'">',cleanNames,'</a>'))
#nodes

visNetwork(nodes, edges, height = "500px", width = "100%")
```

# Gender
```{r}
pairwise = function(exp_GSE, transform_type) {
  
  z = exp_GSE
  
  if (transform_type == "Arc") {
    z = z / max(z)
    z = asin(sqrt(z))
    z = pairwise_col_diff(z) %>% as.matrix()
  }
  else if (transform_type == "Log") {
    z = z + 1
    z = log(z)
    z = pairwise_col_diff(z) %>% as.matrix()
  }
  else if (transform_type == "Pair"){
    z = z %>% as.matrix()
    z_pairwise = pairwise_col_diff(z) %>% as.matrix()

  }
  z = data.frame(z)
  
  return(z)
  
}

calculate_gender = function(dataframe) {
  colnames(dataframe) = tolower(colnames(dataframe))
  outcome = NULL
  if ("outcome" %in% colnames(dataframe)) {
    outcome = dataframe$outcome
    dataframe = select(dataframe, -one_of("outcome"))
}
  if ("xist" %in% colnames(dataframe) && "eif1ay" %in% colnames(dataframe) && "ankrd44" %in% colnames(dataframe)) {
    known_genes = c("xist", "eif1ay", "ankrd44")
    
    outcome_df = dataframe %>% select(known_genes)
    outcome_df = pairwise(outcome_df, transform_type = "Log") %>% as.matrix()
    outcome_df = data.frame(outcome_df)
    
    # Can replace this with an already preprocessed dataframe
   
    p_GSE46474 = pData(GSE46474)
    p_GSE46474$outcome = ifelse(p_GSE46474$characteristics_ch1.1 == "Sex: M", 0, 1) # Male is 0 and female is 1
    exprs_GSE46474 = data.frame(t(exprs(GSE46474)))
    colnames(exprs_GSE46474) = tolower(colnames(exprs_GSE46474))
    exprs_GSE46474 = exprs_GSE46474 %>% select(known_genes)
    exprs_GSE46474 = pairwise(exprs_GSE46474, transform_type="Log") %>% as.matrix()
    exprs_GSE46474 = data.frame(exprs_GSE46474)

    # print(dim(exprs_GSE46474))
    # print(dim(outcome_df))
    
    model = knn(exprs_GSE46474, outcome_df, p_GSE46474$outcome, k = 3)
    
    dataframe$gender = model
    dataframe$outcome = outcome
    
    return(dataframe)
    
  }
  return(NULL)
}

# Add gender and source column to each of the 4 data frames
testInput <- as.data.frame(userExpression)
userExpression <- calculate_gender(testInput)
userExpression$source <- c(rep("userUploadedData", length(rownames(userExpression))))

exp_GSE36059 <- calculate_gender(exp_GSE36059)
exp_GSE36059$source <- c(rep("public", length(rownames(exp_GSE36059))))


exp_GSE48581 <- calculate_gender(exp_GSE48581)
exp_GSE48581$source <- c(rep("public", length(rownames(exp_GSE48581))))


exp_GSE46474 <- calculate_gender(exp_GSE46474)
exp_GSE46474$source <- c(rep("public", length(rownames(exp_GSE46474))))



```






