---
title: "Khang Research 1"
output: html_notebook
---

```{r, include=FALSE}
library(tidyverse)
library(tuneR)
library(devtools)
library(ggplot2)
library(tsfeatures)
library(class)
library(cvTools)
library(randomForest)
library(GEOquery) 
library(R.utils)
library(reshape2)
library(limma)
library(dplyr)
library(e1071)
library(DT)
library(viridis)
library(plotly)
library(scales)
library(CPOP)
library(matrixStats)
library(visNetwork)
library(sva)
```

## Mukund CPOP analysis

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
#CPOP data

# AMY, CHARLOTTE, LIAM, if anyone does this on their local computer, uncomment the following
# original import from server
# GSE46474 = getGEO("GSE46474")[[1]]
# GSE36059 = getGEO("GSE36059")[[1]]
# GSE48581 = getGEO("GSE48581")[[1]]
# The below is what the user uploads
# GSE129166 = getGEO("GSE129166")[[1]]

# write to file, TODO: For each object, please RDS to speed it up
# saveRDS(GSE46474, file = "GSE46474.rds")
# saveRDS(GSE36059, file = "GSE36059.rds")
# saveRDS(GSE129166, file = "GSE129166.rds")


GSE46474 <- readRDS("GSE46474.rds")
GSE36059 <-  readRDS("GSE36059.rds")
GSE48581 <-  readRDS("GSE48581.rds")
GSE129166 <- readRDS("GSE129166.rds")
```

```{r include=FALSE}
gene_names = function(gse) {
  fData(gse)$`Gene Symbol` = unlist(lapply(strsplit(fData(gse)$`Gene Symbol`, " /// ", 1), `[`, 1))

  idx = which(!duplicated(fData(gse)$`Gene Symbol`) & !is.na(fData(gse)$`Gene Symbol`))
  gse = gse[idx,] # get only rows that have a gene symbol that is unique, which enables the rownames
  rownames(gse) = fData(gse)$`Gene Symbol`
  
  return(gse)
}

bridgegse <- GSE129166 # the dataset we want to get the gene symbols from

affymetrixGenes = unlist(lapply(strsplit(fData(bridgegse)$`Gene Symbol`, " /// ", 1), `[`, 1))

idx = which(!duplicated(affymetrixGenes) & !is.na(affymetrixGenes))

bridge =  data.frame(id = fData(bridgegse)$ID[idx], geneName= affymetrixGenes[idx])

# changes probe Ids into gene names
transformProbeIds = function(df){
  temp <- rownames(df)

  rowIndexesToKeep <- c()
  newRowNames <- c()
  for(i in 1:length(temp)){
    curIndex <- which(bridge$id == temp[i])
    if( length(curIndex) == 1 ){
      rowIndexesToKeep <-  c(rowIndexesToKeep, i)
      newRowNames <- c(newRowNames, bridge[curIndex, "geneName"])
    }
  }
  df <- df[rowIndexesToKeep,]
  rownames(df) <- newRowNames
  
  return(df)
}
```


# Create function for user input and compare with 3 datasets

```{r, include=FALSE}
calc_mode <- function(x){
  # List the distinct / unique values
  distinct_values <- unique(x)
  # Count the occurrence of each distinct value
  distinct_tabulate <- tabulate(match(x, distinct_values))
  # Return the value with the highest occurrence
  distinct_values[which.max(distinct_tabulate)]
}
generateCPOPmodel <- function(user,userOutcomes, inhouse, inhouseOutcomes){
  set.seed(3888)
  return(cpop_model(user,
        inhouse,
        userOutcomes,
        inhouseOutcomes,
        w = NULL,
        n_features = 30,
        n_iter = 30,
        alpha = 0,
        family = "binomial",
        s = "lambda.min",
        cpop2_break = TRUE,
        cpop2_type = "sign",
        cpop2_mag = 1,
        cpop1_method = "normal",
        intercept = FALSE))
}


userFile <- data.frame(read_csv('../Liam/Data/dirtyuser.csv', name_repair = "minimal"))
rownames(userFile) <-  tolower(userFile[[1]])
userFile <-  userFile[,-1]
diagnosisIndex <- which(rownames(userFile) == 'diagnosis')

# separate for individual cleaning
userExpression <- userFile[-diagnosisIndex,]
userBinaryOutcomes <-  as.factor(unname(unlist(userFile[diagnosisIndex, ])))

# transform probe ids to gene names, will make userExpression smaller
userExpression <- transformProbeIds(userExpression)
```


```{r include=FALSE}
# I calculate the variance so I can get the userExpression to 2000 rows
myVar = rowVars(as.matrix(userExpression), na.rm=TRUE)
myVar = as.data.frame(myVar)

userExpression = cbind(userExpression, variance = myVar)
userExpression = slice_max(userExpression, order_by = myVar, n = 2000)
userExpression = subset(userExpression, select = -c(myVar))


# length(rownames)


# length(newRowNames)
# length(rownames(userExpression))
# rownames(userExpression) <- newRowNames
# rownames(userExpression) = newRowNames
```


```{r include=FALSE}
# get the row names (probe ids) before transpose
row_names_UE= rownames(userExpression)

userExpression <- as.data.frame(t(userExpression))

# actually clean the userExpression matrix
userExpression <- userExpression %>% mutate_if(is.numeric, ~replace_na(.,mean(., na.rm = TRUE)))

# actually clean the NAs in userBinary Outcomes
f <- calc_mode(userBinaryOutcomes)
majorityClass <- as.numeric(levels(f))[f]
userBinaryOutcomes[is.na(userBinaryOutcomes)] <- majorityClass

# row.names(userExpression) <- newR
# feature1 <-generateCPOPmodel(userExpression,userBinaryOutcomes,z1,y1)



```

```{r,include=FALSE}

GSE46474 = gene_names(GSE46474)
GSE36059 = gene_names(GSE36059)
GSE48581 = gene_names(GSE48581)

## keeping only the 2000 most variable genes in my data frame 
exp_GSE36059 = (exprs(GSE36059))

Variance = rowVars(as.matrix(exp_GSE36059)) #
Variance = as.data.frame(Variance)

exp_GSE36059 = as.data.frame(exp_GSE36059)

exp_GSE36059 = cbind(exp_GSE36059, variance = Variance)
exp_GSE36059 = slice_max(exp_GSE36059, order_by = Variance, n = 2000) # For each column, get the 2000 most variable genes, so you get 2000 rows
exp_GSE36059 = subset(exp_GSE36059, select = -c(Variance))

row_names_exp_GSE36059 = rownames(exp_GSE36059) # used for finding common probe ids
```

# write.csv(exp_GSE129166,"/Users/khangnguyen/Desktop/userUploadData.csv", row.names = TRUE)

```{r, include=FALSE}

## keeping only the 2000 most variable genes in my data frame 
exp_GSE46474 = (exprs(GSE46474))

Variance = rowVars(as.matrix(exp_GSE46474))
Variance = as.data.frame(Variance)
exp_GSE46474 = as.data.frame(exp_GSE46474)


exp_GSE46474 = cbind(exp_GSE46474, variance = Variance)
exp_GSE46474 = slice_max(exp_GSE46474, order_by = Variance, n = 2000)
exp_GSE46474 = subset(exp_GSE46474, select = -c(Variance))
row_names_exp_GSE46474 = rownames(exp_GSE46474)



## keeping only the 2000 most variable genes in my data frame 
exp_GSE48581 = (exprs(GSE48581))
Variance = rowVars(as.matrix(exp_GSE48581))
Variance = as.data.frame(Variance)
exp_GSE48581 = as.data.frame(exp_GSE48581)
exp_GSE48581 = cbind(exp_GSE48581, variance = Variance)
exp_GSE48581 = slice_max(exp_GSE48581, order_by = Variance, n = 2000)
exp_GSE48581 = subset(exp_GSE48581, select = -c(Variance))
row_names_exp_GSE48581 = rownames(exp_GSE48581)
```

```{r, include=FALSE}
## now find the most common probe ids names between 3 datasets
intersection = intersect(row_names_exp_GSE36059, row_names_exp_GSE46474)
intersection = intersect(intersection, row_names_exp_GSE48581)
intersection = intersect(intersection, row_names_UE)
```

```{r, include= FALSE}
# create dataframes that only contains rows common in all dataframes

exp_GSE36059 = as.data.frame(t(as.matrix(exp_GSE36059)))
exp_GSE36059 = subset(exp_GSE36059, select = c(intersection)) # select rows that contain the probe ids in intersection

exp_GSE46474 = as.data.frame(t(as.matrix(exp_GSE46474)))
exp_GSE46474 = subset(exp_GSE46474, select = c(intersection)) # select rows that contain the probe ids in intersection

exp_GSE48581 = as.data.frame(t(as.matrix(exp_GSE48581)))
exp_GSE48581 = subset(exp_GSE48581, select = c(intersection)) # select rows that contain the probe ids in intersection

# no need to transpose as you already have done so above for user expression
userExpression <-  subset(userExpression, select= c(intersection))
```


## getting the results vectors

```{r, include= FALSE}

# CPOP stuff continued
p_GSE46474 = pData(GSE46474) 
p_GSE48581 = pData(GSE48581) 
p_GSE36059 = pData(GSE36059) 

# creating the outcome columns to put inside CPOP
p_GSE36059$diagnosis = ifelse(p_GSE36059$characteristics_ch1 == "diagnosis: non-rejecting", 0, 1)
p_GSE48581$diagnosis = ifelse(p_GSE48581$characteristics_ch1.1 == "diagnosis (tcmr, abmr, mixed, non-rejecting, nephrectomy): non-rejecting", 0, 1)
p_GSE46474$diagnosis = ifelse(p_GSE46474$characteristics_ch1.5 == "procedure status: post-transplant non-rejection (NR)", 0, 1)


z1 = exp_GSE36059 %>% as.matrix() # used for box plots and CPOP
z2 = exp_GSE48581 %>% as.matrix()
z3 = exp_GSE46474 %>% as.matrix()
userExpression <- userExpression %>% as.matrix()

y1 = as.factor(p_GSE36059$diagnosis)
y2 = as.factor(p_GSE48581$diagnosis)
y3 = as.factor(p_GSE46474$diagnosis)

# TODO: Before running CPOP, change the expression matrix probe ids to gene names

### GSE36059
### GSE48581
# these have reject + stable but categorized in more detail -> either have more groups that we are predicting, or we could do purely binary 
```
## CPOP RUN KHANG
<!-- TODO: Implement this pairwise difference in shiny app -->
```{r}

feature1 <- generateCPOPmodel(userExpression,userBinaryOutcomes,z1,y1)
feature2 <- generateCPOPmodel(userExpression,userBinaryOutcomes,z2,y2)
feature3 <- generateCPOPmodel(userExpression,userBinaryOutcomes,z3,y3)

f1 <- feature1$coef_tbl$coef_name[-1] 
f2 <- feature2$coef_tbl$coef_name[-1]
f3 <- feature3$coef_tbl$coef_name[-1]

rI <- intersect(f1,f2)
stableFeatures <- intersect(rI,f3)
# generateCPOPmodel(z1,y1,z2,y2)

# after finding the stable features, get rows relevant in each dataframe and create your own data frame.
# we will do a column bind
tb1 <-  feature1$coef_tbl[feature1$coef_tbl$coef_name %in% stableFeatures,]
tb2 <-  feature2$coef_tbl[feature2$coef_tbl$coef_name %in% stableFeatures,]
tb3 <-  feature3$coef_tbl[feature3$coef_tbl$coef_name %in% stableFeatures,]

results <- tb1 %>% inner_join(tb2, by ="coef_name" ) %>% inner_join(tb3, by ="coef_name" )
results$average <- rowMeans(results[,-1])
# resultTable$average
# -0.12109045	-0.07927375	AGL--ANKRD22
# -0.069795029	-0.025225051 AGL--ANKRD22
# -0.07525255	-0.023783883
# length(stableFeatures)

coef = results$coef_name
```


## VisNetwork!!
```{r}
results = results %>% mutate(color = case_when( average > 0 ~ "blue", average < 0 ~ "red" ))
names = data.frame(feature1 = rep("",length(coef)),
                   feature2 = rep("",length(coef)),
                   coef_size = abs(results$average))
#names
names$feature1 = sub("--.*", "", coef) #getting the first node from the coef-name vector of the results df
names$feature2 = sub(".*--", "", coef) #getting the second node from the coef-name vector of the results df
names$color = results$color
# network = plot_lratio_network(coef, type = "visNetwork")
#network
names_uniq = unique(c(names$feature1, names$feature2))
# names_uniq
numbers = names
#numbers
for (a in 1:nrow(numbers)) {
  for (i in 1:length(names_uniq)) {
    if (numbers$feature2[a] == names_uniq[i]) {
      numbers$feature2[a] = i
    }
  }
}
for (a in 1:nrow(numbers)) {
  for (i in 1:length(names_uniq)) {
    if (numbers$feature1[a] == names_uniq[i]) {
      numbers$feature1[a] = i
    }
  }
}
#numbers
clr = c()
for (a in 1:length(names_uniq)) {
  for (i in 1:nrow(names)) {
    if (names_uniq[a] == names[i,1] | names_uniq[a] == names[i,2]) {
      clr[a] = names$color[i]
    }
  }
}
#clr

cleanNames <- sub("--.*","",names_uniq)


edges = data.frame(from = numbers$feature1, to = numbers$feature2, value = names$coef_size)
nodes = data.frame(id = c(1:length(names_uniq)), 
                   label = names_uniq, 
                   color = clr,
                   title = paste0('<a href = "https://www.genecards.org/cgi-bin/carddisp.pl?gene=',cleanNames,'">',cleanNames,'</a>'))
#nodes
visNetwork(nodes, edges, height = "500px", width = "100%")
```


```{r}
####KHNAG

# names
# use sub to substitute string only on first occurrence in coef
names$feature1 = sub("--.*", "", coef) #getting the first node from the coef-name vector of the results df
names$feature2 = sub(".*--", "", coef) #getting the second node from the coef-name vector of the results df
names$color = results$color
# network = plot_lratio_network(coef, type = "visNetwork")
# network
names_uniq = unique(c(names$feature1, names$feature2))
names_uniq
numbers = names
numbers
for (a in 1:nrow(numbers)) {
  for (i in 1:length(names_uniq)) {
    if (numbers$feature2[a] == names_uniq[i]) {
      numbers$feature2[a] = i # gives each feature an id number
    }
  }
}
for (a in 1:nrow(numbers)) {
  for (i in 1:length(names_uniq)) {
    if (numbers$feature1[a] == names_uniq[i]) {
      numbers$feature1[a] = i # gives each feature an id number
    }
  }
}
numbers
clr = vector()
for (a in 1:length(names_uniq)) {
  for (i in 1:nrow(names)) {
    if (names_uniq[a] == names[i,1] | names_uniq[a] == names[i,2]) {
      clr[a] = names$color[i]
    }
  }
}
clr
names
edges = data.frame(from = numbers$feature1, to = numbers$feature2, value = names$coef_size)
nodes = data.frame(id = c(1:length(names_uniq)), 
                   label = names_uniq)
visNetwork(nodes, edges, height = "500px", width = "100%")

```



## DRAFT RUN Everything below is just junk

```{r}
#CPOP model

counter = 0

# run cpop once for each pair data set 
for (i in c(71)) {
  set.seed(3888)
  counter = counter + 1
  #alpha_vector = seq(0.01, 1, by=0.01)
  alpha_vector = c(1)
  # counter2 = 0
  for(a in alpha_vector){
    # counter2 = counter2 + 1
      cpopresult =
      cpop_model(
        z1,
        z2,
        y1,
        y2,
        w = NULL,
        n_features = 30,
        n_iter = 20,
        alpha = 1,
        family = "binomial",
        s = "lambda.min",
        cpop2_break = TRUE,
        cpop2_type = "sign",
        cpop2_mag = 1,
        cpop1_method = "normal",
        intercept = FALSE)

    prediction_z3 <- predict_cpop(cpopresult, z3, s = "lambda.min")
    }
}
prediction_z3
# y3
```

```{r}
## cross validation code DONT worry will consider later
K = 5  # number of CV folds

bal_acc_y3_test = numeric(length(101))
features_test = numeric(length(101))
y3_alpha_accuracy_list = list()
features_list = list()

# permute all the data, into 5 folds
n1 = nrow(z1_log)
n2 = nrow(z2_log)
cvSets_z1 = cvTools::cvFolds(n1, K) 
cvSets_z2 = cvTools::cvFolds(n2, K) 


cv_acc_z1 = NA  # initialise results vector
cv_acc_z2 = NA
cv_acc_alphas_z1 = NA
cv_acc_alphas_z2 = NA
for (j in 1:K) {
    test_id_z1 = cvSets_z1$subsets[cvSets_z1$which == j]
    test_id_z2 = cvSets_z2$subsets[cvSets_z2$which == j]
    z1_log_test = z1_log[test_id_z1, ]
    z1_log_train = z1_log[-test_id_z1, ]
    y1_test = y1[test_id_z1]
    y1_train = y1[-test_id_z1]
    z2_log_test = z2_log[test_id_z2, ]
    z2_log_train = z2_log[-test_id_z2, ]
    y2_test = y2[test_id_z2]
    y2_train = y2[-test_id_z2]
    

    counter = 0
    
    bal_acc_y3_test = numeric(length(101))
    features_test = numeric(length(101))
    y3_alpha_accuracy_list = list()
    features_list = list()
    
    for (i in c(71)) {
      set.seed(3888)
      counter = counter + 1
      alpha_vector = c(0.01, 0.5, 0.7, 0.9, 1)
      counter2 = 0
      for(a in alpha_vector){
        counter2 = counter2 + 1
          cpopresult=
          cpop_model(
            z1_log_train,
            z2_log_train,
            y1_train,
            y2_train,
            w = NULL,
            n_features = 30,
            n_iter = 20,
            alpha = 1,
            family = "binomial",
            s = "lambda.min",
            cpop2_break = TRUE,
            cpop2_type = "sign",
            cpop2_mag = 1,
            cpop1_method = "normal",
            intercept = FALSE)
    fit_z1 = predict_cpop(cpopresult, z1_log_test, s = "lambda.min")
    fit_z2 = predict_cpop(cpopresult, z2_log_test, s = "lambda.min")
    cv_acc_z1[j] = mean(fit_z1$cpop_model_avg_class == y1_test)
    cv_acc_z2[j] = mean(fit_z2$cpop_model_avg_class == y2_test)
    
    cv_acc_alphas_z1[counter2] = mean(cv_acc_z1)
    cv_acc_alphas_z2[counter2] = mean(cv_acc_z2)
      }
    }
}

cv_acc_z1
cv_acc_z2

cv_acc_alphas_z1
cv_acc_alphas_z2

## make this balanced acc
```

```{r}
results = cpopresult$coef_tbl
results$average = (results$coef1 +results$coef2)/2
results=results[2:nrow(results),]
results = results[order(-abs(results$average)),]
results = results[1:20,c(1,4)]

coef = results$coef_name
# results$coef_name = sub(".*\\.", "", coef) # 

# plot_lratio_network(results$coef_name, type = "visNetwork") # another visnetwork graph

```

```{r}
#playing with network
results =
results %>%
  mutate(color = case_when(
    average > 0 ~ "blue",
    average < 0 ~ "red"
    )) # add color column 

names = data.frame(feature1 = rep("",20),
                   feature2 = rep("",20),
                   coef_size = abs(results$average)) # create a data frame with 3 columns
# names
# use sub to substitute string only on first occurrence in coef
names$feature1 = sub("--.*", "", coef) #getting the first node from the coef-name vector of the results df
names$feature2 = sub(".*--", "", coef) #getting the second node from the coef-name vector of the results df
names$color = results$color
# network = plot_lratio_network(coef, type = "visNetwork")
# network
names_uniq = unique(c(names$feature1, names$feature2))
names_uniq
numbers = names
numbers
for (a in 1:nrow(numbers)) {
  for (i in 1:length(names_uniq)) {
    if (numbers$feature2[a] == names_uniq[i]) {
      numbers$feature2[a] = i # gives each feature an id number
    }
  }
}
for (a in 1:nrow(numbers)) {
  for (i in 1:length(names_uniq)) {
    if (numbers$feature1[a] == names_uniq[i]) {
      numbers$feature1[a] = i # gives each feature an id number
    }
  }
}
numbers
clr = vector()
for (a in 1:length(names_uniq)) {
  for (i in 1:nrow(names)) {
    if (names_uniq[a] == names[i,1] | names_uniq[a] == names[i,2]) {
      clr[a] = names$color[i]
    }
  }
}
clr
names
edges = data.frame(from = numbers$feature1, to = numbers$feature2, value = names$coef_size)
nodes = data.frame(id = c(1:length(names_uniq)), 
                   label = names_uniq)
visNetwork(nodes, edges, height = "500px", width = "100%")



```

# Function that creates dirty csv upload data

```{r}
## Khang's work 
# 
# userFile <- read_csv('../Liam/Data/userUploadData.csv', name_repair = "minimal")
# 
# 
# # rownames(userFile) <- userFile[[1]]
# # userFile['diagnosis',]
# u <- userFile
# 
# set.seed(3888)
# # #
# cname <- tail(colnames(u),-1)
# # #
# amountOFErrors <- 10000
# # #
# # errors <- c(NA,"NA", "na","Na", "nA", "-","rubbish","brah", "/", "", "  ", "    ", "", "-99", -99,0)
# 
# 
# # #
# for (val in cname){
#   curVec <- u[[val]]
#    ind <-  which(curVec %in% sample(curVec,amountOFErrors))
#    # u[[val]][ind] <- sample(errors,1)
#    u[[val]][ind] <- NA
# }
# # 
# write_csv(u,"/Users/khangnguyen/Desktop/dirtyuser.csv")
# 
# u

```

# Create GSE129166

```{r}
# exp_GSE129166 = as.data.frame(exprs(GSE129166))
# # 0 is stable, 1 is rejection
# myP <- pData(GSE129166)
# myP$diagnosis = ifelse(myP$characteristics_ch1.1 == "tcmr (no: 0_borderline:1_TCMR:2): 0" & myP$characteristics_ch1.2 == "abmr (no: 0_Yes:1): 0" , 0, 1)
# 
# output <- rbind(exp_GSE129166, t(cbind(myP[0], diagnosis = myP$diagnosis)))
# 
# output
# 
# write.csv(output,"/Users/khangnguyen/Documents/DATA3888/DATA3888-kidneyC6/Research/Liam/Data/userUploadData.csv", row.names = TRUE)

```

# BoxPlot - arcSine and log


```{r}
## arcsine transformation


exp_GSE36059_arc <- exp_GSE36059
exp_GSE36059_arc = exp_GSE36059_arc / max(exp_GSE36059_arc)
exp_GSE36059_arc = asin(sqrt(exp_GSE36059_arc))

exp_GSE46474_arc <- exp_GSE46474
exp_GSE46474_arc = exp_GSE46474_arc / max(exp_GSE46474_arc)
exp_GSE46474_arc = asin(sqrt(exp_GSE46474_arc))

exp_GSE48581_arc <- exp_GSE48581
exp_GSE48581_arc = exp_GSE48581_arc / max(exp_GSE48581_arc)
exp_GSE48581_arc = asin(sqrt(exp_GSE48581_arc))

# use for box plots
z1_arc = pairwise_col_diff(exp_GSE36059_arc) %>% as.matrix()
z3_arc = pairwise_col_diff(exp_GSE46474_arc) %>% as.matrix()
z2_arc = pairwise_col_diff(exp_GSE48581_arc) %>% as.matrix()
```

```{r}
## log transform

exp_GSE36059_log <- exp_GSE36059
exp_GSE36059_log = exp_GSE36059_log + 1
exp_GSE36059_log = log(exp_GSE36059_log)

exp_GSE46474_log <- exp_GSE46474
exp_GSE46474_log = exp_GSE46474_log + 1
exp_GSE46474_log = log(exp_GSE46474_log)

exp_GSE48581_log <- exp_GSE48581
exp_GSE48581_log = exp_GSE48581_log + 1
exp_GSE48581_log = log(exp_GSE48581_log)

#use for box plot
z1_log = pairwise_col_diff(exp_GSE36059_log) %>% as.matrix()
z3_log = pairwise_col_diff(exp_GSE46474_log) %>% as.matrix()
z2_log = pairwise_col_diff(exp_GSE48581_log) %>% as.matrix()

```

## pre transformation plot

```{r}
GSE36059_id <- data.frame("Dataset" = rep("GSE36059",nrow(exp_GSE36059))) # used for boxplots
GSE46474_id <- data.frame("Dataset" = rep("GSE46474",nrow(exp_GSE46474)))
GSE48581_id <- data.frame("Dataset" = rep("GSE48581",nrow(exp_GSE48581)))


# no pairwise difference for z1,z2,z3
box11 = cbind(boxplot_tbl(z1, index = 1), GSE36059_id)
box22 = cbind(boxplot_tbl(z3, index = 1), GSE46474_id)
box33 = cbind(boxplot_tbl(z2, index = 1), GSE48581_id)
box4 = rbind(box11, box22, box33)

expressionplot <-
ggplot(data = box4, aes(x = object, y = means)) +
  geom_point(aes(color = Dataset), size = 0.1) +
  geom_errorbar(aes(ymin = q1,
                    ymax = q3,
                    color = Dataset), size = 0.1,  alpha = 0.2) +
  ggsci::scale_color_d3() +
  theme(axis.ticks = element_blank()) +
  theme(axis.text.x = element_blank()) +
  theme(axis.title.x=element_blank()) +
  theme(axis.title.y=element_blank()) +
  ylim(0,15) + 
  theme(legend.position="bottom") +
  theme(legend.title = element_blank()) +
  labs(title = "Raw Data") +
  theme(plot.title = element_text(size=10))

expressionplot
```

## Boxplot to visualise if the arc transformations were good

```{r}
# arc transformations

box1_arc = cbind(boxplot_tbl(z1_arc, index = 1), GSE36059_id)
box2_arc = cbind(boxplot_tbl(z3_arc, index = 1), GSE46474_id)
box3_arc = cbind(boxplot_tbl(z2_arc, index = 1), GSE48581_id)
box4_arc = rbind(box1_arc, box2_arc, box3_arc)

arcplot <-
ggplot(data = box4_arc, aes(x = object, y = means)) +
  geom_point(aes(color = Dataset), size = 0.1) +
  geom_errorbar(aes(ymin = q1,
                    ymax = q3,
                    color = Dataset), size = 0.1,  alpha = 0.2) +
  ggsci::scale_color_d3() +
  theme(axis.ticks = element_blank()) +
  theme(axis.text.x = element_blank()) +
  xlab("Samples") +
  theme(axis.title.y=element_blank()) +
  labs(title = "Arcsine transformation + pairwise difference") +
  theme(plot.title = element_text(size=10))

arcplot
```

## boxplot to see if the log transformation was good

```{r}
box1_log = cbind(boxplot_tbl(z1_log, index = 1), GSE36059_id)
box2_log = cbind(boxplot_tbl(z3_log, index = 1), GSE46474_id)
box3_log = cbind(boxplot_tbl(z2_log, index = 1), GSE48581_id)
box4_log = rbind(box1_log, box2_log, box3_log)

logplot <-
ggplot(data = box4_log, aes(x = object, y = means)) +
  geom_point(aes(color = Dataset), size = 0.1) +
  geom_errorbar(aes(ymin = q1,
                    ymax = q3,
                    color = Dataset), size = 0.1,  alpha = 0.2) +
  ggsci::scale_color_d3() +
  theme(axis.ticks = element_blank()) +
  theme(axis.text.x = element_blank()) +
  xlab("Samples") +
  theme(axis.title.y=element_blank()) +
  labs(title = "Log transformation + pairwise difference") +
  theme(plot.title = element_text(size=10))

logplot
```
