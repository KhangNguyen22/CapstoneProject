---
title: "Khang Research 1"
output: html_notebook
---

```{r, include=FALSE}
library(GEOquery)
library(tidyverse)
library(dplyr)
library(CPOP)
library(matrixStats)
library(visNetwork)
library(furrr)
library(tictoc)
library(class)
library(ggplot2)
```

## Mukund CPOP analysis

```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
#CPOP data

# AMY, CHARLOTTE, LIAM, if anyone does this on their local computer, uncomment the following
# original import from server
# GSE46474 = getGEO("GSE46474")[[1]]
# GSE36059 = getGEO("GSE36059")[[1]]
# GSE48581 = getGEO("GSE48581")[[1]]
# The below is what the user uploads
# GSE129166 = getGEO("GSE129166")[[1]]

# write to file, TODO: For each object, please RDS to speed it up
# saveRDS(GSE46474, file = "GSE46474.rds")
# saveRDS(GSE36059, file = "GSE36059.rds")
# saveRDS(GSE129166, file = "GSE129166.rds")


GSE46474 <- readRDS("GSE46474.rds")
GSE36059 <-  readRDS("GSE36059.rds")
GSE48581 <-  readRDS("GSE48581.rds")
# GSE129166 <- readRDS("GSE129166.rds")
```

```{r include=FALSE}


# TODO: make this into an rds object that you can reference later
# bridgegse <- GSE46474 # the dataset we want to get the gene symbols from
# 
# affymetrixGenes = unlist(lapply(strsplit(fData(bridgegse)$`Gene Symbol`, " /// ", 1), `[`, 1))
# 
# idx = which(!duplicated(affymetrixGenes) & !is.na(affymetrixGenes))

bridge =  readRDS("bridge.rds")
# saveRDS(bridge, file = "../../shinyapp/data/bridge.rds")


gene_names = function(gse) {
  fData(gse)$`Gene Symbol` = unlist(lapply(strsplit(fData(gse)$`Gene Symbol`, " /// ", 1), `[`, 1))

  idx = which(!duplicated(fData(gse)$`Gene Symbol`) & !is.na(fData(gse)$`Gene Symbol`))
  gse = gse[idx,] # get only rows that have a gene symbol that is unique, which enables the rownames
  rownames(gse) = fData(gse)$`Gene Symbol`
  
  return(gse)
}

# changes probe Ids into gene names
transformProbeIds = function(df){
  temp <- rownames(df)

  rowIndexesToKeep <- c()
  newRowNames <- c()
  for(i in 1:length(temp)){
    curIndex <- which(bridge$id == temp[i])
    if( length(curIndex) == 1 ){
      rowIndexesToKeep <-  c(rowIndexesToKeep, i)
      newRowNames <- c(newRowNames, bridge[curIndex, "geneName"])
    }
  }
  df <- df[rowIndexesToKeep,]
  rownames(df) <- newRowNames
  
  return(df)
}
```


# Create function for user input and compare with 3 datasets

```{r, include=FALSE}
calc_mode <- function(x){
  # List the distinct / unique values
  distinct_values <- unique(x)
  # Count the occurrence of each distinct value
  distinct_tabulate <- tabulate(match(x, distinct_values))
  # Return the value with the highest occurrence
  distinct_values[which.max(distinct_tabulate)]
}

set.seed(3888)
generateCPOPmodel <- function(user,userOutcomes, public){
  return(cpop_model(user,
        public[[1]], # public[1] is the expression matrix only
        userOutcomes,
        public[[2]], #public[2] is the public Outcomes
        w = NULL,
        n_features = 30,
        n_iter = 30,
        alpha = 0,
        family = "binomial",
        s = "lambda.min",
        cpop2_break = TRUE,
        cpop2_type = "sign",
        cpop2_mag = 1,
        cpop1_method = "normal",
        intercept = FALSE))
}
```


```{r include=FALSE}
# user inputs their file upload
userFile <- data.frame(read_csv('../Liam/Data/dirtyuser.csv', name_repair = "minimal"))
rownames(userFile) <-  tolower(userFile[[1]])
userFile <-  userFile[,-1]
diagnosisIndex <- which(rownames(userFile) == 'diagnosis')

# separate for individual cleaning
userExpression <- userFile[-diagnosisIndex,]
userBinaryOutcomes <-  as.factor(unname(unlist(userFile[diagnosisIndex, ])))

# transform probe ids to gene names, will make userExpression smaller
userExpression <- transformProbeIds(userExpression)

# I calculate the variance so I can get the userExpression to 2000 rows
myVar = rowVars(as.matrix(userExpression), na.rm=TRUE)
myVar = as.data.frame(myVar)

userExpression = cbind(userExpression, variance = myVar)
userExpression = slice_max(userExpression, order_by = myVar, n = 2000)
userExpression = subset(userExpression, select = -c(myVar))

# get the row names (probe ids) before transpose
row_names_UE= rownames(userExpression)

userExpression <- as.data.frame(t(userExpression))

# actually clean the userExpression matrix
userExpression <- userExpression %>% mutate_if(is.numeric, ~replace_na(.,mean(., na.rm = TRUE)))

# actually clean the NAs in userBinary Outcomes
f <- calc_mode(userBinaryOutcomes)
majorityClass <- as.numeric(levels(f))[f]
userBinaryOutcomes[is.na(userBinaryOutcomes)] <- majorityClass

# row.names(userExpression) <- newR
# feature1 <-generateCPOPmodel(userExpression,userBinaryOutcomes,z1,y1)



```

```{r,include=FALSE}

GSE46474 = gene_names(GSE46474)
GSE36059 = gene_names(GSE36059)
GSE48581 = gene_names(GSE48581)
# TODO: save RDS object  of the exp_GSE expression dataframes
## keeping only the 2000 most variable genes in my data frame 
exp_GSE36059 = (exprs(GSE36059))

Variance = rowVars(as.matrix(exp_GSE36059)) #
Variance = as.data.frame(Variance)

exp_GSE36059 = as.data.frame(exp_GSE36059)

exp_GSE36059 = cbind(exp_GSE36059, variance = Variance)
exp_GSE36059 = slice_max(exp_GSE36059, order_by = Variance, n = 2000) # For each column, get the 2000 most variable genes, so you get 2000 rows
exp_GSE36059 = subset(exp_GSE36059, select = -c(Variance))

row_names_exp_GSE36059 = rownames(exp_GSE36059) # used for finding common probe ids


## keeping only the 2000 most variable genes in my data frame 
exp_GSE46474 = (exprs(GSE46474))

Variance = rowVars(as.matrix(exp_GSE46474))
Variance = as.data.frame(Variance)
exp_GSE46474 = as.data.frame(exp_GSE46474)


exp_GSE46474 = cbind(exp_GSE46474, variance = Variance)
exp_GSE46474 = slice_max(exp_GSE46474, order_by = Variance, n = 2000)
exp_GSE46474 = subset(exp_GSE46474, select = -c(Variance))
row_names_exp_GSE46474 = rownames(exp_GSE46474)



## keeping only the 2000 most variable genes in my data frame 
exp_GSE48581 = (exprs(GSE48581))
Variance = rowVars(as.matrix(exp_GSE48581))
Variance = as.data.frame(Variance)
exp_GSE48581 = as.data.frame(exp_GSE48581)
exp_GSE48581 = cbind(exp_GSE48581, variance = Variance)
exp_GSE48581 = slice_max(exp_GSE48581, order_by = Variance, n = 2000)
exp_GSE48581 = subset(exp_GSE48581, select = -c(Variance))
row_names_exp_GSE48581 = rownames(exp_GSE48581)
```

```{r, include=FALSE}
## now find the most common probe ids names between 3 datasets
intersection = intersect(row_names_exp_GSE36059, row_names_exp_GSE46474)
intersection = intersect(intersection, row_names_exp_GSE48581)
intersection = intersect(intersection, row_names_UE)
```

```{r, include= FALSE}
# create dataframes that only contains rows common in all dataframes
exp_GSE36059 = as.data.frame(t(as.matrix(exp_GSE36059)))
exp_GSE36059 = subset(exp_GSE36059, select = c(intersection)) # select rows that contain the probe ids in intersection

exp_GSE46474 = as.data.frame(t(as.matrix(exp_GSE46474)))
exp_GSE46474 = subset(exp_GSE46474, select = c(intersection)) # select rows that contain the probe ids in intersection

exp_GSE48581 = as.data.frame(t(as.matrix(exp_GSE48581)))
exp_GSE48581 = subset(exp_GSE48581, select = c(intersection)) # select rows that contain the probe ids in intersection

# no need to transpose as you already have done so above for user expression
userExpression <-  subset(userExpression, select= c(intersection))
```


## getting the results vectors

```{r, include= FALSE}

# CPOP stuff continued
p_GSE46474 = pData(GSE46474) 
p_GSE48581 = pData(GSE48581) 
p_GSE36059 = pData(GSE36059) 

# creating the outcome columns to put inside CPOP
p_GSE36059$diagnosis = ifelse(p_GSE36059$characteristics_ch1 == "diagnosis: non-rejecting", 0, 1)
p_GSE48581$diagnosis = ifelse(p_GSE48581$characteristics_ch1.1 == "diagnosis (tcmr, abmr, mixed, non-rejecting, nephrectomy): non-rejecting", 0, 1)
p_GSE46474$diagnosis = ifelse(p_GSE46474$characteristics_ch1.5 == "procedure status: post-transplant non-rejection (NR)", 0, 1)


z1 = exp_GSE36059 %>% as.matrix() # used for box plots and CPOP
z2 = exp_GSE48581 %>% as.matrix()
z3 = exp_GSE46474 %>% as.matrix()
userExpression <- userExpression %>% as.matrix()

y1 = as.factor(p_GSE36059$diagnosis)
y2 = as.factor(p_GSE48581$diagnosis)
y3 = as.factor(p_GSE46474$diagnosis)



### GSE36059
### GSE48581
# these have reject + stable but categorized in more detail -> either have more groups that we are predicting, or we could do purely binary 
```
## CPOP RUN KHANG
<!-- TODO: Implement this pairwise difference in shiny app -->

```{r include=FALSE}
future::plan(multisession)

cpopOutputs <- future_map(list(list(z1,y1),list(z2,y2), list(z3,y3)), generateCPOPmodel, user= userExpression, userOutcomes=userBinaryOutcomes)

```


```{r}
f1 <-  cpopOutputs[[1]]$coef_tbl$coef_name[-1] 
f2 <- cpopOutputs[[2]]$coef_tbl$coef_name[-1]
f3 <- cpopOutputs[[3]]$coef_tbl$coef_name[-1]

rI <- intersect(f1,f2)
stableFeatures <- intersect(rI,f3)
# generateCPOPmodel(z1,y1,z2,y2)

# after finding the stable features, get rows relevant in each dataframe and create your own data frame.
# we will do a column bind
tb1 <-  cpopOutputs[[1]]$coef_tbl[cpopOutputs[[1]]$coef_tbl$coef_name %in% stableFeatures,]
tb2 <-  cpopOutputs[[2]]$coef_tbl[cpopOutputs[[2]]$coef_tbl$coef_name %in% stableFeatures,]
tb3 <-  cpopOutputs[[3]]$coef_tbl[cpopOutputs[[3]]$coef_tbl$coef_name %in% stableFeatures,]


results <- tb1 %>% inner_join(tb2, by ="coef_name" ) %>% inner_join(tb3, by ="coef_name" )


  

results$average <- rowMeans(results[,-1])
# resultTable$average
# -0.12109045	-0.07927375	AGL--ANKRD22
# -0.069795029	-0.025225051 AGL--ANKRD22
# -0.07525255	-0.023783883
# length(stableFeatures)

coef = results$coef_name

# makeVisnetwork(results)
# makeVisnetwork(cpopOutputs[[1]]$coef_tbl)
# makeVisnetwork(cpopOutputs[[3]]$coef_tbl)
# saveRDS(stableFeatures, file = "../../shinyapp/data/stableFeatures.rds")
cpopOutputs[[1]]$coef_tbl
```


## VisNetwork!!
```{r}
makeVisnetwork <- function(cpopDF){
  cpopDF$average <- rowMeans(cpopDF[,-1])
  coef <- cpopDF$coef_name
  names = data.frame(feature1 = rep("",length(coef)),
                   feature2 = rep("",length(coef)),
                   coef_size = abs(cpopDF$average))
  #names
  names$feature1 = sub("--.*", "", coef) #getting the first node from the coef-name vector of the cpopDF df
  names$feature2 = sub(".*--", "", coef) #getting the second node from the coef-name vector of the cpopDF df
  # names$color = results$color
  # network = plot_lratio_network(coef, type = "visNetwork")
  #network
  names_uniq = unique(c(names$feature1, names$feature2))
  # names_uniq
  numbers = names
  #numbers
  for (a in 1:nrow(numbers)) {
    for (i in 1:length(names_uniq)) {
      if (numbers$feature2[a] == names_uniq[i]) {
        numbers$feature2[a] = i
      }
    }
  }
  for (a in 1:nrow(numbers)) {
    for (i in 1:length(names_uniq)) {
      if (numbers$feature1[a] == names_uniq[i]) {
        numbers$feature1[a] = i
      }
    }
  }
  #numbers
  clr = c()
  for (a in 1:length(names_uniq)) {
    for (i in 1:nrow(names)) {
      if (names_uniq[a] == names[i,1] | names_uniq[a] == names[i,2]) {
        clr[a] = names$color[i]
      }
    }
  }
  #clr
  
  cleanNames <- sub("--.*","",names_uniq)
  
  edges = data.frame(from = numbers$feature1, to = numbers$feature2, value = names$coef_size)
  nodes = data.frame(id = c(1:length(names_uniq)), 
                     label = names_uniq, 
                     # color = clr,
                     title = paste0('<a href = "https://www.genecards.org/cgi-bin/carddisp.pl?gene=',cleanNames,'">',cleanNames,'</a>'))
  #nodes
  
  return(visNetwork(nodes, edges, height = "500px", width = "100%"))
}

makeVisnetwork(results) 
```


```{r}
# TODO: 3 visnetworks please show me!
vis1 <- makeVisnetwork(cpopOutputs[[1]]$coef_tbl) 
vis2 <- makeVisnetwork(cpopOutputs[[2]]$coef_tbl) 
vis3 <- makeVisnetwork(cpopOutputs[[3]]$coef_tbl) 
# saveRDS(vis1,"../../shinyapp/data/vis1.rds")
```

# Gender
```{r}
pairwise = function(exp_GSE, transform_type) {
  
  z = exp_GSE
  
  if (transform_type == "Arc") {
    z = z / max(z)
    z = asin(sqrt(z))
    z = pairwise_col_diff(z) %>% as.matrix()
  }
  else if (transform_type == "Log") {
    # z = log(z +1)
    # removing weird AGL name added.
    z <- pairwise_col_diff(log(z +1))
    colnames(z) <- sub(".*\\.","",colnames(z))
    z = z %>% as.matrix()
  }
  else if (transform_type == "Pair"){
    z = z %>% as.matrix()
    z_pairwise = pairwise_col_diff(z) %>% as.matrix()

  }
  z = data.frame(z)
  
  return(z)
  
}
# returns gender vector
calculate_gender = function(dataframe) {
  colnames(dataframe) = tolower(colnames(dataframe))
  # outcome = NULL
#   if ("outcome" %in% colnames(dataframe)) {
#     outcome = dataframe$outcome
#     dataframe = select(dataframe, -one_of("outcome"))
# }
  if ("xist" %in% colnames(dataframe) && "eif1ay" %in% colnames(dataframe) && "ankrd44" %in% colnames(dataframe)) {
    # known_genes =  c()
    
    outcome_df = dataframe %>% select("xist", "eif1ay","ankrd44")
    outcome_df = pairwise(outcome_df, transform_type = "Log") %>% as.matrix()
    outcome_df = data.frame(outcome_df)
    
    # Can replace this with an already preprocessed dataframe
   
    p_GSE46474 = pData(GSE46474)
    p_GSE46474$outcome = ifelse(p_GSE46474$characteristics_ch1.1 == "Sex: M", 0, 1) # Male is 0 and female is 1
    exprs_GSE46474 = data.frame(t(exprs(GSE46474)))
    colnames(exprs_GSE46474) = tolower(colnames(exprs_GSE46474))
    exprs_GSE46474 = exprs_GSE46474 %>% select("xist", "eif1ay","ankrd44")
    exprs_GSE46474 = pairwise(exprs_GSE46474, transform_type="Log") %>% as.matrix()
    exprs_GSE46474 = data.frame(exprs_GSE46474)

    # print(dim(exprs_GSE46474))
    # print(dim(outcome_df))
    
    model = knn(exprs_GSE46474, outcome_df, p_GSE46474$outcome, k = 3)
    
    # dataframe$gender = model
    # dataframe$outcome = outcome
    
    return(model)
    
  }
  return(NULL)
}

# saveRDS(userExpression, "ue.rds")
# userExpression <- readRDS("ue.rds")

# Add gender and source column to each of the 4 data frames
ue <- pairwise(userExpression, "Log")
temp_GSE36059 <- pairwise(exp_GSE36059, "Log")
temp_GSE48581 <- pairwise(exp_GSE48581, "Log")
temp_GSE46474 <- pairwise(exp_GSE46474, "Log")

boxplotInput <- bind_rows(temp_GSE36059,temp_GSE48581, temp_GSE46474,ue )

ue$outcome <- userBinaryOutcomes
ue$gender <- calculate_gender(as.data.frame(userExpression))
ue$source <- c(rep("userUploadedData", length(rownames(userExpression))))



temp_GSE36059$outcome <- y1
temp_GSE36059$gender <- calculate_gender(exp_GSE36059)
temp_GSE36059$source <- c(rep("public GSE36059", length(rownames(exp_GSE36059))))



temp_GSE48581$outcome <- y2
temp_GSE48581$gender <- calculate_gender(exp_GSE48581)
temp_GSE48581$source <- c(rep("public GSE48581", length(rownames(exp_GSE48581))))


temp_GSE46474$outcome <- y3
temp_GSE46474$gender <- calculate_gender(exp_GSE46474)
temp_GSE46474$source <- c(rep("public GSE46474", length(rownames(exp_GSE46474))))



combinedDataset <-  bind_rows(temp_GSE36059,temp_GSE48581, temp_GSE46474,ue )
 
colnames(combinedDataset) <- sub("\\.\\.","-", colnames(combinedDataset))
```

```{r}
# TODO: the colourful boxplot for the combined dataset, and colour by the source

compareCombinedData = cbind(boxplot_tbl(boxplotInput, index =1), source= combinedDataset$source)



ggplot(data = compareCombinedData, aes(x = object, y = means)) +
  geom_point(aes(color = source), size = 0.1) +
  geom_errorbar(aes(ymin = q1,
                    ymax = q3,
                    color = source), size = 0.1,  alpha = 0.2) +
  ggsci::scale_color_d3() +
  theme(axis.ticks = element_blank()) +
  theme(axis.text.x = element_blank()) +
  xlab("Samples") +
  theme(axis.title.y=element_blank()) +
  labs(title = "Log transformation + pairwise difference") +
  theme(plot.title = element_text(size=10))


```





#Bottom

